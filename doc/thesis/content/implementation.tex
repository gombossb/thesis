\chapter{Implementation}

The implementation of the box model, according to the plans discussed in the previous chapter, mostly went without issues and was able to be put into practice. This chapter presents the steps of implementation in detail.

\section{Floorplan}

\begin{figure}[!ht]
    \centering
    \includegraphics[page=1,keepaspectratio,width=110mm]{figures/box_floorplan.drawio.pdf}
    \caption{Floorplan of the finished box model}
    \label{fig:BoxFloorplan}
\end{figure}

The shoebox used as a base for the project was structured with cardboard and scotch tape to have six equal-sized rooms inside it, shown on \refstruc{fig:BoxFloorplan}. Internal and external cutouts were made in the box to be able to push cables through them, have ventilation holes for the fans and a window for the rolling shutter, to be seen from outside.

\section{Connecting devices to the microcontroller}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=150mm, keepaspectratio]{figures/nodemcu_32s_pinout.png}
    \caption{NodeMCU ESP32S Pinout}
    \label{fig:NodeMCU32Pinout}
\end{figure}

The NodeMCU ESP32S has many ports with different functionalities, as shown on \refstruc{fig:NodeMCU32Pinout}. \cite{AIThinkerNodeMCU32} It has a Micro-USB port that can be used for supplying power and connection to a computer for programming, flashing firmware and serial console. The 5V supplied from the USB port is connected to the VIN 5V pin and there is also a VIN 3.3V port from a voltage converter for supplying power to lower-voltage external components, besides the three ground pins. There are many more GPIO (General-Purpose Input/Output) pins with different input-output functionalities, however not every of them can be used for every purpose. For example, ADC/DAC pins can be used for Analog-Digital Conversion or vice-versa, therefore sense or create voltages between 0V and 3.3V, some can output PWM (Pulse Width Modulation) signals for dimming LEDs, controlling servos etc., serial pins can be used for serial communication, SD card interfacing and there are some only binary input-output pins. The 3.3V, 5V and ground pins were connected via short cables to the power rail sides of the main breadboard for easy distribution of power to components and for the other components, mostly jumper cables were used. Jumper cables and wires were used to connect most components to the breadboards, which also served as extension to have appropriate length of cables for the components to be able to put into their desired location in the box. The method for cable splicing varied, for some, soldering and shrink tubes were used and for others, only electrical tape was used due to the smoke detection system installed in the dormitory.

\begin{figure}[!ht]
    \centering
    \includegraphics[page=1,keepaspectratio,width=150mm]{figures/box_block_diag.drawio.pdf}
    \caption{Simplified block diagram of components and their wirings inside the box}
    \label{fig:BoxBlockDiag}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=150mm, keepaspectratio]{figures/box_photo.jpg}
    \caption{Photo of the finished box model}
    \label{fig:BoxPhoto}
\end{figure}

The microcontroller's number of pins and their functionalities were adequate the project, extra components can be added up to the limit the available free pins and the required features on them. The pins used for room LEDs were chosen to be non-ADC GPIO pins and for each one, 100$\Omega$ resistors were put between the LED's anode and the microcontroller pin, the cathode was connected to the side ground of the breadboard. An LED put inside a small toy car was also connected to a PWM-capable pin with 50$\Omega$ resistance in series to indicate a simulated electric charging based on the readings of the light dependant resistor (LDR). The LDR's wiring required a different approach: one end connected to the 3.3V rail, and the other to one of the microcontroller's ADC pins, and to the ground with a 10k$\Omega$ resistor. The three LM235Z temperature sensors were connected with yet another wiring method: 2k$\Omega$ resistors were put between 5V and their V+ terminals, to this the ADC pins were also connected and finally, the V- pins were connected to ground. The SG90 servo was connected to 5V, ground and a PWM capable pin for control. Due to the limited space remaining on the first breadboard, a second one was utilized for the fan and Peltier powering circuit. The ground between the two breadboard was connected and a USB cable with male plugs spliced was created to utilize external power from a 5V 2A phone charger. The 5V fans are powered and speed controlled by BS170 transistors by varying the voltage supplied for them: PWM pins are connected to the gate terminal, along with 10k$\Omega$ resistors to ground, the source terminal connected to ground and diodes placed between 5V and drain to protect the microcontroller from the inductive load of fans. The fans' negative terminals were connected to drain and the positive to 5V. Finally, the TEC1-12703 Peltier module is powered and controlled by a BD241C transistor (with extra cooling attached in the form of soda can tab openers screwed into it). This Peltier module's maximum operating voltage is rated to be 15.4V, which means, when run at a lower voltage, it draws less current, therefore has lower power. According to its datasheet, at 5V, its current is approximately 0.8A, therefore the device draws about 4 watts of power and it decreases with more ambient temperature as the current gets less. \cite{PeltierDatasheet} 300$\Omega$ resistance was used between one of the DAC pins and the transistor's base, the emittor was connected to ground and the Peltier's terminals were connected to the collector and 5V. On \refstruc{fig:BoxBlockDiag}, a simplified block diagram of components and their wirings inside the box is shown without resistors, ground connections and exact pinout of components and on \refstruc{fig:BoxPhoto}, a photo of the finished box model is shown.

\section{Network setup}

The Wi-Fi communication medium was set up using a TP-Link WR841N combined network device, targeted for small or home office use. Such devices almost always feature a web-based user interface for their setup and configuration. This was used to flash DD-WRT on it, which is an open-source Linux-based router firmware targeting a variety of Wi-Fi routers and embedded systems. \cite{DDWRTHomepage} It was then set up to mimick a typical home environment, with an SSID of esp\_smart\_home, WPA2-PSK authentication and without internet connectivity and without NAT (Network Address Translation, by setting the operation mode from gateway to router). The IP address range remained the default 192.168.1.0/24 and the router's IP also remained the original 192.168.1.1, due to it not colliding with other networks actively used on the laptop and smartphone.

An extra USB Wi-Fi adapter at hand was used for connecting the laptop to the Wi-Fi network, with a custom network profile configuration. Initially, the use of this adapter was done with a network profile limited to the specific network adapter and manual IP configuration was used instead of DHCP to ensure a fixed IP address of 192.168.1.100 and no default gateway learned from this network. Later, it was passed through as a USB device to a virtual machine (VM) with the same Wi-Fi and IP configuration. The Android-based smartphone used for the project can also be connected to this network, which even though doesn't have Internet access, mobile data can still be used from its SIM card as a fallback for Internet connectivity.

\section{Software setup}

The selected software environment in planning was suitable for the usage of obtained hardware, this section showcases the steps taken for software setup. The personal laptop used for development had a Linux distribution installed, the smartphone used for testing ran Android 14. 

\subsection{HomeAssistant initial setup}

Initially, Home Assistant was set up in a Docker container environment running on the laptop, with a Docker Compose file specifying the parameters for the container. Docker Engine is a container runtime engine, that makes it possible to run prepackaged container images utilizing the host machine's kernel with minimal overhead and adequate isolation. \cite{DockerContainer} The container images contain a Linux operating system's system libraries, executables and the application itself, therefore provide an easily reproducible, uniform runtime environment despite the differences in various systems. By itself, Docker has a command line interface to run and manage its containers, which means it has to be parameterized from the command line, or put into a script in its parameterized form and executed. Docker Compose is a solution for defining and running multiple Docker containers using an easy-to-manage definition, put into a YAML file. \cite{DockerCompose}

\begin{lstlisting}[language=,caption=Docker Compose file used for the initial Home Assistant environment,label=lst:HADockerCompose]
services:
  homeassistant:
    container_name: homeassistant
    image: "ghcr.io/home-assistant/home-assistant:2024.10.3"
    volumes:
      - ./config:/config
      - /etc/localtime:/etc/localtime:ro
      - /run/dbus:/run/dbus:ro
    ports:
      - 192.168.1.100:8123:8123
      - 127.0.0.1:8123:8123
\end{lstlisting}

In \refstruc{lst:HADockerCompose}, the Docker Compose definition of the set up Home Assistant container can be seen: 2024.10.3 is the selected version (tag) of the image is used, the config directory from the compose file's directory is mounted directly into the container's file system as /config along with the host machine's local time and dbus for time and device access, and finally, socket connections are bound on the host machine's 8123 port on the Wi-Fi card and localhost interfaces to access the same port inside the container. Even though only one container is defined in the compose file, it still shows Compose's advantage, as the environment can be run with a simple command in the terminal, when inside its directory:

\begin{lstlisting}[language=]
docker compose up
\end{lstlisting}

This setup in the Docker environment functioned properly, however had one limitation: HomeAssistant add-ons aren't supported in the container variant, only in the Home Assistant Operating System or the Supervised installation (installed on top of a Linux distribution) variants. A voice assistant was a sought after feature in the project, therefore it was migrated to the HA OS variant, run inside a Virtual Machine, or VM.

Virtual Machine Hypervisors allow physical, or host computer resources to be shared to multiple Virtual Machines, or guest machines. \cite{VMwareVM} Each virtual machine can run it's own separately with its own amount of CPU cores, RAM, storage and other kinds of resources. Virtual Machines are widely used today in IT infrastructures, as the technology makes it easier to create heterogeneous software environments and can offer less downtime with clusterized servers. The most popular current virtualization solutions include VMware products, Oracle VirtualBox and Proxmox. \cite{G2freeVM}

To run HA OS, the selected VM hypervisor solution was Oracle VirtualBox, due to it being free and and the previous experience gained with it. HA OS is distributed in different disk file formats for various hypervisors, VDI was used for VirtualBox. % todo ha source?
Initially, 2 virtual CPU cores and 2 GB of RAM of the host's 16 GB was assigned to it, however it was later changed to 4 cores and 4 GB of RAM. Two virtual network adapters were added to the VM: one in NAT mode, to provide Internet connection and one in Host-only adapter mode, to be able to be reached from the host (on it's web UI (8123) and SSH (22) ports). Most VM hypervisors offer USB passthrough to virtual machines, which hides the USB device from the host and makes it seem as it was connected to it directly. USB passthrough was used to access the USB Wi-Fi adapter and the network credentials were set via a parameterized \verb+ha network+ command. The SSH addon was also installed to access command line configurations from client terminal installed on the host operating system.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=150mm, keepaspectratio]{figures/homeassistant_about.png}
  \caption{Home Assistant OS running in VirtualBox with its web GUI opened from a browser}
  \label{fig:HAabout}
\end{figure}

\subsection{ESPHome}

To get started with installing ESPHome on the microcontroller, its official getting started with command line guide was followed. \cite{ESPHomeGettingStarted} A sample configuration YAML file was created using the wizard command. The ESPHome compiler and flasher was run from a Docker environment, first flashed via USB and later updated wirelessly using ESPHome's the Over-the-Air (OTA) functionality via Wi-Fi.

\begin{lstlisting}[language=,caption=Docker command to compile and flash ESPHome via OTA / USB,label=lst:ESPHomeDocker]
# for first flashing, add: --device=/dev/ttyUSB0
docker run --rm -v "./esphome":/config -it ghcr.io/esphome/esphome:2024.11.1 run smarthome.yaml
\end{lstlisting}

The previously mentioned YAML is a human-friendly data serialization language with a really simple syntax. \cite{YAMLHomepage}

\begin{lstlisting}[language=,caption=YAML file example,label=lst:YAMLexample]
shopping_list:
  - bread
  - milk
  - chocolate
# ideal room temperature
temperature: 22
winter_months: ["December", "January", "February"]
\end{lstlisting}

By default, an ESPHome configuration file only consists of one main YAML file, which contains all configurations. On \refstruc{lst:ESPHomeWizardEx}, an excerpt of a configuration file is shown generated by the wizard for the NodeMCU ESP32S microcontroller.

\begin{lstlisting}[language=,caption=Excerpt of a configuration file generated by the ESPHome wizard,label=lst:ESPHomeWizardEx]
esphome:
  name: livingroom
esp32:
  board: nodemcu-32s
  framework:
    type: arduino
ota:
  - platform: esphome
    password: ""
wifi:
  ssid: "homenetwork"
  password: "teriyaki-noodles"
\end{lstlisting}

After successfully flashing the compiled firmware to the microcontroller, it can then be added to the Home Assistant environment with an "integration". Integration is a term in Home Assistant's ecosystem to connect and integrate other software and hardware platforms, in our case ESPHome to the Home Assistant environment as a device. \cite{HAConceptsTerminology}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=150mm, keepaspectratio]{figures/homeassistant_esphome_int.png}
  \caption{ESPHome integration for Home Assistant set up}
  \label{fig:HAesphomeint}
\end{figure}

ESPHome supports many types of electronic components connected to the microcontroller's pins (as the project's homepage shows), with a relatively easy configuration. \cite{ESPHomeHomepage} To set devices up to be controlled with ESPHome, their configuration has to be defined in the YAML configuration file, as shown in \refstruc{lst:ESPHomeDevConf} for an LED switch.

\begin{lstlisting}[language=,caption=ESPHome configuration for a simple LED switch,label=lst:ESPHomeDevConf]
switch:
- platform: gpio
  id: bedroom_led
  pin:
    number: GPIO21
    mode: OUTPUT
  name: "BedroomLED"
  restore_mode: ALWAYS_OFF
\end{lstlisting}

set up devices, packages

entity

sg90 mention post?

\subsection{Additional user interface setup}

entity customization

dashboard

\subsection{Automations}

TODO eg. car charging led

\subsection{Smartphone setup}

TODO

\subsection{Voice assistant}

addons
